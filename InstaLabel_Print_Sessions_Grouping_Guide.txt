# InstaLabel.co - Print Sessions Grouping Guide

## Overview
This guide explains how the InstaLabel.co system groups individual print logs into print sessions for better organization and user experience. The grouping logic intelligently combines related print operations that were performed together.

## Data Structure

### PrintLog Interface
```typescript
interface PrintLog {
  id: number
  user_id: string
  action: string
  details: {
    itemId: string
    itemName: string
    quantity: number
    labelType: "cooked" | "prep" | "ppds"
    printedAt: string
    initial?: string
    labelHeight?: LabelHeight
    printerUsed?: {
      name: string
      uri: string
      state: string
    }
    sessionId?: string  // Key field for grouping
  }
  timestamp: string
}
```

### GroupedPrintSession Interface
```typescript
interface GroupedPrintSession {
  sessionId: string
  timestamp: string
  printedAt: string
  items: PrintLog[]
  printerUsed?: {
    name: string
    uri: string
    state: string
  }
  initial?: string
  labelHeight?: LabelHeight
}
```

## Grouping Logic

### Primary Grouping Strategy
The system uses a **two-tier grouping approach**:

1. **Primary**: Use `sessionId` if available (explicit session grouping)
2. **Fallback**: Generate session key based on timestamp and printer (implicit grouping)

### Session Key Generation
```typescript
const sessionKey = log.details.sessionId || 
  `${new Date(log.timestamp).getTime()}-${log.details.printerUsed?.name || "unknown"}`
```

**Explanation:**
- **Explicit Session**: When `sessionId` is provided, it's used directly
- **Implicit Session**: When no `sessionId`, creates a key using:
  - Timestamp (milliseconds since epoch)
  - Printer name
  - Format: `{timestamp}-{printerName}`

### Grouping Algorithm
```typescript
function groupPrintSessions(printLogs: PrintLog[]): GroupedPrintSession[] {
  if (printLogs.length === 0) {
    return [];
  }

  const grouped: { [key: string]: PrintLog[] } = {};

  // Group logs by session key
  printLogs.forEach((log) => {
    const sessionKey = log.details.sessionId || 
      `${new Date(log.timestamp).getTime()}-${log.details.printerUsed?.name || "unknown"}`;
    
    if (!grouped[sessionKey]) {
      grouped[sessionKey] = [];
    }
    grouped[sessionKey].push(log);
  });

  // Convert to GroupedPrintSession array
  const sessions: GroupedPrintSession[] = Object.entries(grouped).map(([sessionId, logs]) => {
    const firstLog = logs[0];
    return {
      sessionId,
      timestamp: firstLog.timestamp,
      printedAt: firstLog.details.printedAt,
      items: logs,
      printerUsed: firstLog.details.printerUsed,
      initial: firstLog.details.initial,
      labelHeight: firstLog.details.labelHeight,
    };
  });

  // Sort by timestamp (newest first)
  sessions.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

  return sessions;
}
```

## Session Types

### 1. Explicit Sessions (sessionId provided)
**When**: Print operations are explicitly grouped by the printing system
**Example**: Batch printing multiple items in one operation
```json
{
  "sessionId": "batch-2024-01-15-10-30-00",
  "items": [
    {"itemName": "Chicken Breast", "quantity": 5},
    {"itemName": "Beef Steak", "quantity": 3},
    {"itemName": "Salmon Fillet", "quantity": 2}
  ]
}
```

### 2. Implicit Sessions (fallback grouping)
**When**: Individual print operations are grouped by time proximity and printer
**Example**: Multiple items printed within the same time window on the same printer
```json
{
  "sessionId": "1705312200000-HP_LaserJet_Pro",
  "items": [
    {"itemName": "Chicken Breast", "timestamp": "2024-01-15T10:30:00Z"},
    {"itemName": "Beef Steak", "timestamp": "2024-01-15T10:30:05Z"},
    {"itemName": "Salmon Fillet", "timestamp": "2024-01-15T10:30:10Z"}
  ]
}
```

## Implementation Details

### 1. Data Fetching
```typescript
async function fetchPrintSessions() {
  const token = localStorage.getItem("token");
  const response = await fetch(`/api/logs`, {
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    },
  });
  
  const data = await response.json();
  
  // Filter only print_label actions
  const printLabelLogs = (data.logs || []).filter(
    (log: any) => log.action === "print_label"
  );
  
  return printLabelLogs;
}
```

### 2. Grouping Process
```typescript
useEffect(() => {
  if (printLogs.length === 0) {
    setGroupedSessions([]);
    return;
  }

  const grouped: { [key: string]: PrintLog[] } = {};

  printLogs.forEach((log) => {
    const sessionKey = log.details.sessionId ||
      `${new Date(log.timestamp).getTime()}-${log.details.printerUsed?.name || "unknown"}`;
    
    if (!grouped[sessionKey]) {
      grouped[sessionKey] = [];
    }
    grouped[sessionKey].push(log);
  });

  // Convert to GroupedPrintSession array
  const sessions: GroupedPrintSession[] = Object.entries(grouped).map(([sessionId, logs]) => {
    const firstLog = logs[0];
    return {
      sessionId,
      timestamp: firstLog.timestamp,
      printedAt: firstLog.details.printedAt,
      items: logs,
      printerUsed: firstLog.details.printerUsed,
      initial: firstLog.details.initial,
      labelHeight: firstLog.details.labelHeight,
    };
  });

  // Sort by timestamp (newest first)
  sessions.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

  setGroupedSessions(sessions);
}, [printLogs]);
```

### 3. Search and Filtering
```typescript
useEffect(() => {
  const filtered = groupedSessions.filter((session) => {
    const itemNames = session.items.map((item) => item.details.itemName).join(" ");
    return itemNames.toLowerCase().includes(search.toLowerCase());
  });
  setFilteredSessions(filtered);
}, [search, groupedSessions]);
```

## Helper Functions

### 1. Get Item Names
```typescript
function getItemNames(session: GroupedPrintSession): string {
  return session.items.map((item) => item.details.itemName).join(", ");
}
```

### 2. Get Total Quantity
```typescript
function getTotalQuantity(session: GroupedPrintSession): number {
  return session.items.reduce((total, item) => total + item.details.quantity, 0);
}
```

### 3. Get Label Types
```typescript
function getLabelTypes(session: GroupedPrintSession): string {
  const types = [...new Set(session.items.map((item) => item.details.labelType))];
  return types.map((type) => type.toUpperCase()).join(", ");
}
```

## UI Display

### Session Card Example
```typescript
function PrintSessionCard({ session }: { session: GroupedPrintSession }) {
  return (
    <div className="session-card">
      <div className="session-header">
        <h3>Print Session</h3>
        <span className="timestamp">{formatTimestamp(session.timestamp)}</span>
      </div>
      
      <div className="session-details">
        <p><strong>Items:</strong> {getItemNames(session)}</p>
        <p><strong>Total Quantity:</strong> {getTotalQuantity(session)}</p>
        <p><strong>Label Types:</strong> {getLabelTypes(session)}</p>
        <p><strong>Printer:</strong> {session.printerUsed?.name || "Unknown"}</p>
      </div>
      
      <div className="session-items">
        {session.items.map((item, index) => (
          <div key={index} className="item">
            <span>{item.details.itemName}</span>
            <span>Qty: {item.details.quantity}</span>
            <span>{item.details.labelType.toUpperCase()}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

## Benefits of Session Grouping

### 1. **Better Organization**
- Related print operations are grouped together
- Easier to understand what was printed in a single session

### 2. **Improved User Experience**
- Users can see complete print sessions at a glance
- Reduces clutter in the logs view

### 3. **Analytics and Reporting**
- Track complete print sessions rather than individual items
- Better insights into printing patterns

### 4. **Reprint Functionality**
- Users can reprint entire sessions with one click
- Maintains the original print configuration

## Edge Cases and Considerations

### 1. **Missing sessionId**
- System falls back to timestamp + printer grouping
- May group unrelated items if printed close together

### 2. **Different Printers**
- Items printed on different printers won't be grouped together
- Ensures printer-specific session isolation

### 3. **Time-based Grouping**
- Implicit grouping uses exact timestamp
- Very precise timing prevents false groupings

### 4. **Session Replay**
- Complete sessions can be reprinted
- Maintains original print settings and order

## Integration Example

### Complete Implementation
```typescript
function PrintSessionsPage() {
  const [printLogs, setPrintLogs] = useState<PrintLog[]>([]);
  const [groupedSessions, setGroupedSessions] = useState<GroupedPrintSession[]>([]);
  const [filteredSessions, setFilteredSessions] = useState<GroupedPrintSession[]>([]);
  const [search, setSearch] = useState("");

  // Fetch print logs
  useEffect(() => {
    async function fetchPrintSessions() {
      const logs = await fetchPrintSessions();
      setPrintLogs(logs);
    }
    fetchPrintSessions();
  }, []);

  // Group sessions
  useEffect(() => {
    const sessions = groupPrintSessions(printLogs);
    setGroupedSessions(sessions);
  }, [printLogs]);

  // Filter sessions
  useEffect(() => {
    const filtered = groupedSessions.filter((session) => {
      const itemNames = session.items.map((item) => item.details.itemName).join(" ");
      return itemNames.toLowerCase().includes(search.toLowerCase());
    });
    setFilteredSessions(filtered);
  }, [search, groupedSessions]);

  return (
    <div className="print-sessions-page">
      <div className="search-bar">
        <input
          type="text"
          placeholder="Search sessions..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
        />
      </div>
      
      <div className="sessions-list">
        {filteredSessions.map((session) => (
          <PrintSessionCard key={session.sessionId} session={session} />
        ))}
      </div>
    </div>
  );
}
```

## Best Practices

### 1. **Session ID Generation**
- Use meaningful session IDs when possible
- Include timestamp and context in session IDs

### 2. **Fallback Logic**
- Always provide fallback grouping for logs without sessionId
- Use consistent fallback key generation

### 3. **Performance**
- Cache grouped sessions to avoid re-computation
- Use efficient data structures for grouping

### 4. **User Experience**
- Show clear session boundaries
- Provide session-level actions (reprint, delete, etc.)

## Support

For questions about print session grouping or implementation, contact the InstaLabel.co development team.

